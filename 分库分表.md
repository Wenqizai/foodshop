# 概述

## 模式

实现读写分离和数据切分的两种模式：

- 中间层代理：MyCat
- 客户端代理：Sharding-jdbc

<img src="https://i.loli.net/2021/05/03/x89uQVMv4mIoWq7.png" alt="image-20210503164613856" style="zoom:50%;" />

## 垂直切分

> 如何切分？

- 按照业务去切分
- 每种业务一个数据库
- 不同业务之间，禁止跨库join联查

> 优缺点

`优点`

- 拆分后业务清晰，拆分规则明确；
- 系统之间容易扩展和整合；
- 数据维护简单。

`缺点`

- 部分业务表无法join，只能通过接口调用，提升系统的复杂度；
- 跨库事务难以处理；
- 垂直切分后，某些业务数据过于庞大，仍然存在单体性能的瓶颈。

<img src="https://i.loli.net/2021/05/03/D9tVnkrXoZvE2Ku.png" alt="image-20210503165456625" style="zoom:50%;" />

## 水平切分

> 如何切分？

- 将一张表的数据按照某种规则分到不同的数据库中；（如用户id，订单id等）；
- 需要确定分片的规则；
- 使用分片字段查询时，可确定实体库，其他字段查询，查询所有表。

> 优缺点

`优点`

- 解决了单库大数据，高并发的性能瓶颈；
- 拆分规则封装好，对应用端几乎透明，开发人员无需关心拆分细节。

`缺点`

- 拆分规则很难抽象；
- 分片事务一致性难以解决；
- 二次扩展时，数据迁移，维护难度大。

<img src="https://i.loli.net/2021/05/03/unCpwSVkDcxNiFQ.png" alt="image-20210503170704166" style="zoom:50%;" />

# MyCat

## 配置

> server.xml

- 配置MyCat的用户名、密码、权限、Schema等
- 如同给MySQL新建用户一样
- 客户端连接MyCat与连接MySQL无异

```xml
<user name="root" defaultAccount="true">
  <property name="password">root</property>
  <!-- schema：配置schema名称，多个则使用导号隔开。此配置需和schema.xml的名称对应 -->
  <property name="schemas">user</property>
  <property name="defaultSchema">TESTDB</property>
</user>

<user name="user">
  <property name="password">user</property>
  <property name="schemas">user</property> 
  <property name="readOnly">true</property>
  <property name="defaultSchema">TESTDB</property>
</user>
```

> schema.xml

- dataHost(节点主机)：包括读host，写host
- dataNode(数据节点)：指定到具体的数据库
- schema：表名、数据节点、分片规则等

```xml
<!-- auto sharding by id (long) -->
<!--splitTableNames 启用<table name 属性使用逗号分割配置多个表,即多个表使用这个配置-->
<!-- checkSQLschema：是否要去掉SQL中的schema -->
<!-- sqlMaxLimit：select默认的limit值，仅对分片表有效 -->
<!-- table定义表，name定义逻辑表表名，dataNode定义逻辑表数据节点，
		 rule定义分片表规则，必须与rule.xml中的tableRule对应，
		 ruleRequired是否绑定分片规则，true没有绑定分片规则，程序报错
-->
<schema name="user" checkSQLschema="true" sqlMaxLimit="100" >
  <table name="user" dataNode="dn120,dn121" rule="auto-sharding-long" />
</schema>

<dataNode name="dn120" dataHost="db120" database="user_120" />
<dataNode name="dn121" dataHost="db121" database="user_121" />

<!-- balance:读请求负载均衡，0不开始读写分离，1和2读写均匀分配，3读落在readHost上 -->
<!-- writeType:写请求负载均衡，0写操作落在第一个writeHost，第一个挂了切换到第二个writeHost 
														1所有写操作都随机的发送到配置的writeHost			
-->
<!-- switchType: 1默认值不自动切换，2基于MySQL主从同步状态决定是否切换  -->
<dataHost name="db120" maxCon="1000" minCon="10" balance="0"
          writeType="0" dbType="mysql" dbDriver="jdbc" switchType="1"  slaveThreshold="100">
  <heartbeat>select user()</heartbeat>
  <writeHost host="M1" url="jdbc:mysql://192.168.8.120:3306" user="root" password="root"></writeHost>
</dataHost>

<dataHost name="db121" maxCon="1000" minCon="10" balance="0"
          writeType="0" dbType="mysql" dbDriver="jdbc" switchType="1"  slaveThreshold="100">
  <heartbeat>select user()</heartbeat>
  <writeHost host="M1" url="jdbc:mysql://192.168.8.121:3306" user="root" password="root"></writeHost>
</dataHost>
```

`rule规则`

- auto-sharding-long：指定分片字段，id等
- sharding-by-intfile：分片枚举
- mod-long：取余分片

## 全局表

全局表的数据在每个分片节点均存放相同一份，这样可以避免关联表查询时，存在跨节点的情况。

```xml
<table name="province" dataNode="dn120,dn121" type="global" />
```

## 子表

其将子表的存储位置依赖于主表，并且物理上紧邻存放，因此彻底解决了 JION 的效率和性能问题。换言之，子表的数据跟随着主表的分片规则存放在那个库，子表就放在那个库。

```xml
<table name="o_order" dataNode="dn120,dn121" rule="auto-sharding-long" >
  <childTable name="order_item" joinKey="order_id" parentKey="id"/>
</table>
```

## HA高可用

![image-20210507124741653](https://i.loli.net/2021/05/07/MnWIDjet2y8NKo1.png)

> Haproxy安装与使用

```shell
# 安装haproxy
yum search haproxy
yum install -y haproxy.x86_64
# 修改配置文件
vim /etc/haproxy/haproxy.cfg
# 启动haproxy
haproxy -f /etc/haproxy/haproxy.cfg
```

> keepalived

```shell
# 修改配置文件
vim /etc/keepalived/keepalived.conf
# 操作keepalived
systemctl status keepalived
systemctl start keepalived
systemctl stop keepalived
```

[问题：Keepalived配置完成后VIP无法平通，虚拟服务器端口无法访问](https://blog.csdn.net/weixin_43279032/article/details/88661712)

